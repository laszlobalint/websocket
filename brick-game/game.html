<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game</title>
  </head>
  <body>
    <canvas id="game-canvas" width="800" height="600"></canvas>
    <script>
      const PADDLE_WIDTH = 100;
      const PADDLE_THICKNESS = 10;
      const PADDLE_DIST_FROM_EDGE = 60;
      const BRICK_W = 80;
      const BRICK_H = 20;
      const BRICK_GAP = 2;
      const BRICK_COLUMNS = 10;
      const BRICK_ROWS = 14;
      const brickGrid = new Array(BRICK_COLUMNS * BRICK_ROWS);

      let paddleX = 400;
      let ballX = 75;
      let ballY = 75;
      let ballSpeedX = 5;
      let ballSpeedY = 7;
      let mouseX = 0;
      let mouseY = 0;
      let canvas, canvasContext;

      function updateMousePosition(evt) {
        const rect = canvas.getBoundingClientRect();
        const root = document.documentElement;
        mouseX = evt.clientX - rect.left - root.scrollLeft;
        mouseY = evt.clientY - rect.top - root.scrollTop;
        paddleX = mouseX - PADDLE_WIDTH / 2;
      }

      function brickReset() {
        for (let i = 0; i < BRICK_COLUMNS * BRICK_ROWS; i++) Math.random() < 0.5 ? (brickGrid[i] = true) : (brickGrid[i] = false);
      }

      window.onload = function () {
        canvas = document.getElementById('game-canvas');
        canvasContext = canvas.getContext('2d');

        let framesPerSecond = 30;
        setInterval(updateAll, 1000 / framesPerSecond);

        canvas.addEventListener('mousemove', updateMousePosition);

        brickReset();
      };

      function updateAll() {
        moveAll();
        drawAll();
      }

      function resetBall() {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
      }

      function moveAll() {
        ballX += ballSpeedX;
        ballY += ballSpeedY;
        if (ballX > canvas.width || ballX < 0) ballSpeedX *= -1;
        if (ballY > canvas.height || ballY < 0) ballSpeedY *= -1;
        if (ballY > canvas.height) resetBall();

        let paddleTopY = canvas.height - PADDLE_DIST_FROM_EDGE;
        let paddleBottomY = paddleTopY + PADDLE_THICKNESS;
        let paddleLeftX = paddleX;
        let paddleRightX = paddleLeftX + PADDLE_WIDTH;

        if (ballY > paddleTopY && ballSpeedY < paddleBottomY && ballX > paddleLeftX && ballX < paddleRightX) {
          ballSpeedY *= -1;
          let centerOfPaddleX = paddleX + PADDLE_WIDTH / 2;
          let ballDistFromPaddleCenterX = ballX - centerOfPaddleX;
          ballSpeedX = ballDistFromPaddleCenterX * 0.35;
        }
      }

      function drawAll() {
        // Clear screen
        colorRect(0, 0, canvas.width, canvas.height, 'black');
        // Draw ball
        colorCircle(ballX, ballY, 10, 'white');
        // Draw paddle
        colorRect(paddleX, canvas.height - PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, 'white');
        // Draw bricks
        drawBricks();
        // Write text by mouse
        colorText(`${Math.floor(mouseX / BRICK_W)}, ${Math.floor(mouseY / BRICK_H)}`, mouseX, mouseY, 'yellow');
      }

      function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
        var mouseBrickX = mouseX;
        canvasContext.fillStyle = fillColor;
        canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
      }

      function colorCircle(centerX, centerY, radius, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.beginPath();
        canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        canvasContext.fill();
      }

      function colorText(showWords, textX, textY, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillText(showWords, textX, textY);
      }

      function drawBricks() {
        for (let eachRow = 0; eachRow < BRICK_ROWS; eachRow++) {
          for (let eachCol = 0; eachCol < BRICK_COLUMNS; eachCol++) {
            let arrayIndex = BRICK_COLUMNS * eachRow + eachCol;
            if (brickGrid[arrayIndex]) colorRect(BRICK_W * eachCol, BRICK_H * eachRow, BRICK_W - BRICK_GAP, BRICK_H - BRICK_GAP, 'blue');
          }
        }
      }
    </script>
  </body>
</html>
